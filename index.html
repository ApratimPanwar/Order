<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Composer | Design Order Analysis Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #E5E7EB;
            color: #1F2937;
            overflow: hidden;
        }

        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: white;
        }

        .header {
            background: #1F2937;
            color: white;
            padding: 12px 20px;
            border-bottom: 3px solid #111827;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 1.4em;
            margin-bottom: 2px;
            font-weight: 700;
        }

        .header .subtitle {
            font-size: 0.8em;
            opacity: 0.8;
        }

        .main-workspace {
            display: grid;
            grid-template-columns: 320px 1fr 360px;
            flex: 1;
            min-height: 0;
            gap: 0;
        }

        /* Left Panel - Algorithmic Controls */
        .order-modes {
            background: #F9FAFB;
            border-right: 2px solid #E5E7EB;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 15px 12px 10px;
            background: white;
            border-bottom: 2px solid #E5E7EB;
            flex-shrink: 0;
        }

        .panel-title {
            font-size: 1.1em;
            font-weight: 700;
            color: #111827;
            margin-bottom: 6px;
        }

        .panel-description {
            font-size: 0.75em;
            color: #6B7280;
            line-height: 1.4;
            padding: 8px;
            background: #F9FAFB;
            border-radius: 4px;
            border-left: 3px solid #1F2937;
        }

        .modes-container {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .mode-btn {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 6px;
            border: 2px solid #E5E7EB;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s ease;
            font-size: 0.85em;
        }

        .mode-btn:hover {
            border-color: #1F2937;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }

        .mode-btn.active {
            background: #1F2937;
            color: white;
            border-color: #1F2937;
        }

        .mode-btn-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mode-btn-title {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .info-icon {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #6B7280;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            cursor: help;
            font-weight: bold;
        }

        .mode-btn.active .info-icon {
            background: #F59E0B;
        }

        .mode-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            margin-top: 0;
        }

        .mode-details.expanded {
            max-height: 500px;
            margin-top: 10px;
        }

        .detail-section {
            padding: 8px;
            background: #F9FAFB;
            border-radius: 4px;
            margin-bottom: 6px;
            font-size: 0.75em;
        }

        .detail-section h4 {
            font-weight: 600;
            margin-bottom: 4px;
            color: #111827;
        }

        .detail-section p {
            line-height: 1.4;
            color: #4B5563;
            margin-bottom: 6px;
        }

        .code-snippet {
            background: #1F2937;
            color: #10B981;
            padding: 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.7em;
            overflow-x: auto;
            white-space: pre;
        }

        /* Center Panel - Canvas */
        .canvas-section {
            padding: 15px;
            background: #FFFFFF;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
        }

        .canvas-wrapper {
            background: #F9FAFB;
            border: 2px solid #E5E7EB;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            border: 2px solid #D1D5DB;
            border-radius: 4px;
            background: white;
        }

        .quick-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            flex: 1;
            padding: 8px 16px;
            border: 2px solid #1F2937;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
            color: #1F2937;
            font-size: 0.85em;
        }

        .action-btn:hover {
            background: #1F2937;
            color: white;
        }

        .order-analysis {
            background: #F9FAFB;
            padding: 15px;
            border-radius: 6px;
            border: 2px solid #E5E7EB;
        }

        .score-display {
            text-align: center;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 2px solid #E5E7EB;
        }

        .overall-score {
            font-size: 2.5em;
            font-weight: 700;
            color: #1F2937;
        }

        .score-category {
            font-size: 0.9em;
            color: #6B7280;
            font-weight: 600;
            margin-top: 4px;
        }

        .principle-score {
            display: grid;
            grid-template-columns: 90px 1fr 50px;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .principle-name {
            font-weight: 600;
            color: #374151;
            font-size: 0.8em;
        }

        .principle-bar {
            height: 8px;
            background: #E5E7EB;
            border-radius: 4px;
            overflow: hidden;
        }

        .principle-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .principle-value {
            font-weight: 700;
            color: #1F2937;
            text-align: right;
            font-size: 0.8em;
        }

        /* Right Panel - Manual Controls */
        .element-controls {
            background: #F9FAFB;
            border-left: 2px solid #E5E7EB;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .element-controls .panel-header {
            padding: 15px 12px 10px;
        }

        .controls-container {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .element-group {
            margin-bottom: 12px;
        }

        .element-group-title {
            font-weight: 700;
            color: #111827;
            font-size: 0.85em;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: white;
            border-radius: 4px;
            border: 2px solid #E5E7EB;
        }

        .element-card {
            background: white;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 6px;
            border: 2px solid #E5E7EB;
            transition: all 0.2s ease;
        }

        .element-card.active {
            border-color: #1F2937;
        }

        .element-card.hidden {
            opacity: 0.4;
        }

        .element-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .element-name {
            font-weight: 600;
            font-size: 0.75em;
            color: #374151;
        }

        .toggle-btn {
            background: #1F2937;
            color: white;
            border: none;
            padding: 3px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7em;
            font-weight: 600;
        }

        .toggle-btn.hidden-state {
            background: #9CA3AF;
        }

        .element-controls-compact {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .compact-control {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .compact-label {
            font-size: 0.7em;
            color: #6B7280;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #D1D5DB;
            outline: none;
            -webkit-appearance: none;
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #1F2937;
            cursor: pointer;
        }

        input[type="color"] {
            width: 100%;
            height: 28px;
            border: 2px solid #D1D5DB;
            border-radius: 4px;
            cursor: pointer;
        }

        .size-control, .rotation-control {
            grid-column: 1 / -1;
        }

        .footer {
            background: #1F2937;
            color: white;
            padding: 8px 20px;
            font-size: 0.7em;
            text-align: center;
            flex-shrink: 0;
            border-top: 2px solid #111827;
        }

        .footer-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0.8;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #F3F4F6;
        }

        ::-webkit-scrollbar-thumb {
            background: #9CA3AF;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #6B7280;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- TOP: Header -->
        <div class="header">
            <h1>🎨 Order Composer: Interactive Design Analysis Tool</h1>
            <p class="subtitle">A computational approach to understanding and applying principles of visual order</p>
        </div>

        <!-- MIDDLE: Three-Panel Workspace -->
        <div class="main-workspace">
            <!-- LEFT PANEL: Algorithmic Order Modes -->
            <div class="order-modes">
                <div class="panel-header">
                    <div class="panel-title">Algorithmic Order Modes</div>
                    <div class="panel-description">
                        Apply computational design principles. Click ⓘ for details.
                    </div>
                </div>
                
                <div class="modes-container">
                
                <button class="mode-btn" onclick="toggleModeDetails(this, 'shape')">
                    <div class="mode-btn-header">
                        <span class="mode-btn-title">
                            <span>🔷</span>
                            <span>Shape Grouping</span>
                        </span>
                        <span class="info-icon">ⓘ</span>
                    </div>
                    <div class="mode-details">
                        <div class="detail-section">
                            <h4>Algorithm</h4>
                            <p>Groups elements by shape type and clusters each using centroid positioning.</p>
                        </div>
                        <div class="detail-section">
                            <h4>Code Logic</h4>
                            <div class="code-snippet">groups[type].forEach((elem, i) => {
  angle = i * (2π / count);
  elem.x = centerX + cos(angle) * 50;
  elem.y = centerY + sin(angle) * 50;
});</div>
                        </div>
                    </div>
                </button>

                <button class="mode-btn" onclick="toggleModeDetails(this, 'size')">
                    <div class="mode-btn-header">
                        <span class="mode-btn-title">
                            <span>📏</span>
                            <span>Size Uniformity</span>
                        </span>
                        <span class="info-icon">ⓘ</span>
                    </div>
                    <div class="mode-details">
                        <div class="detail-section">
                            <h4>Algorithm</h4>
                            <p>Normalizes all elements to average size, snapped to 8px grid.</p>
                        </div>
                        <div class="detail-section">
                            <h4>Code Logic</h4>
                            <div class="code-snippet">avgSize = sum(sizes) / count;
gridSize = round(avgSize / 8) * 8;
elements.forEach(e => e.size = gridSize);</div>
                        </div>
                    </div>
                </button>

                <button class="mode-btn" onclick="toggleModeDetails(this, 'grid')">
                    <div class="mode-btn-header">
                        <span class="mode-btn-title">
                            <span>📐</span>
                            <span>Strict Grid</span>
                        </span>
                        <span class="info-icon">ⓘ</span>
                    </div>
                    <div class="mode-details">
                        <div class="detail-section">
                            <h4>Algorithm</h4>
                            <p>Enforces 8px modular grid for all positions and sizes.</p>
                        </div>
                        <div class="detail-section">
                            <h4>Code Logic</h4>
                            <div class="code-snippet">elem.x = round(elem.x / 8) * 8;
elem.y = round(elem.y / 8) * 8;
elem.rotation = round(elem.rotation / 15) * 15;</div>
                        </div>
                    </div>
                </button>

                <button class="mode-btn" onclick="toggleModeDetails(this, 'hierarchy')">
                    <div class="mode-btn-header">
                        <span class="mode-btn-title">
                            <span>📊</span>
                            <span>Visual Hierarchy</span>
                        </span>
                        <span class="info-icon">ⓘ</span>
                    </div>
                    <div class="mode-details">
                        <div class="detail-section">
                            <h4>Algorithm</h4>
                            <p>Applies golden ratio (φ = 1.618) sizing based on visual weight.</p>
                        </div>
                        <div class="detail-section">
                            <h4>Code Logic</h4>
                            <div class="code-snippet">weight = size*0.4 + contrast*0.3 + position*0.2;
sorted.forEach((e, rank) => {
  e.size = 150 / pow(φ, rank * 0.6);
});</div>
                        </div>
                    </div>
                </button>

                <button class="mode-btn" onclick="toggleModeDetails(this, 'rhythm')">
                    <div class="mode-btn-header">
                        <span class="mode-btn-title">
                            <span>🎵</span>
                            <span>Rhythmic Spacing</span>
                        </span>
                        <span class="info-icon">ⓘ</span>
                    </div>
                    <div class="mode-details">
                        <div class="detail-section">
                            <h4>Algorithm</h4>
                            <p>Equal intervals with alternating size pattern (large-small).</p>
                        </div>
                        <div class="detail-section">
                            <h4>Code Logic</h4>
                            <div class="code-snippet">spacing = canvasWidth / (count + 1);
elements.forEach((e, i) => {
  e.x = spacing * (i + 1);
  e.size = i % 2 === 0 ? 80 : 60;
});</div>
                        </div>
                    </div>
                </button>

                <button class="mode-btn" onclick="toggleModeDetails(this, 'proximity')">
                    <div class="mode-btn-header">
                        <span class="mode-btn-title">
                            <span>👥</span>
                            <span>Proximity Clustering</span>
                        </span>
                        <span class="info-icon">ⓘ</span>
                    </div>
                    <div class="mode-details">
                        <div class="detail-section">
                            <h4>Algorithm</h4>
                            <p>Iterative attraction toward nearest neighbors.</p>
                        </div>
                        <div class="detail-section">
                            <h4>Code Logic</h4>
                            <div class="code-snippet">for (pass = 0; pass < 10; pass++) {
  nearest = findNearest(e);
  e.x += (nearest.x - e.x) * 0.3;
  e.y += (nearest.y - e.y) * 0.3;
}</div>
                        </div>
                    </div>
                </button>

                <button class="mode-btn" onclick="toggleModeDetails(this, 'balance')">
                    <div class="mode-btn-header">
                        <span class="mode-btn-title">
                            <span>⚖️</span>
                            <span>Visual Balance</span>
                        </span>
                        <span class="info-icon">ⓘ</span>
                    </div>
                    <div class="mode-details">
                        <div class="detail-section">
                            <h4>Algorithm</h4>
                            <p>Perceptual center using gamma correction (γ=2.2).</p>
                        </div>
                        <div class="detail-section">
                            <h4>Code Logic</h4>
                            <div class="code-snippet">L = pow(0.2126*R + 0.7152*G + 0.0722*B, 1/2.2);
centerX = sum(x * weight) / sum(weight);
offset = canvasCenter - centerX;</div>
                        </div>
                    </div>
                </button>

                <button class="mode-btn" onclick="toggleModeDetails(this, 'rotation')">
                    <div class="mode-btn-header">
                        <span class="mode-btn-title">
                            <span>🔄</span>
                            <span>Rotation Alignment</span>
                        </span>
                        <span class="info-icon">ⓘ</span>
                    </div>
                    <div class="mode-details">
                        <div class="detail-section">
                            <h4>Algorithm</h4>
                            <p>Aligns all elements to average rotation angle.</p>
                        </div>
                        <div class="detail-section">
                            <h4>Code Logic</h4>
                            <div class="code-snippet">avgRotation = atan2(
  mean(sin(rotations)),
  mean(cos(rotations))
);</div>
                        </div>
                    </div>
                </button>

                <button class="mode-btn" onclick="toggleModeDetails(this, 'avgface')">
                    <div class="mode-btn-header">
                        <span class="mode-btn-title">
                            <span>➡️</span>
                            <span>Average Face Direction</span>
                        </span>
                        <span class="info-icon">ⓘ</span>
                    </div>
                    <div class="mode-details">
                        <div class="detail-section">
                            <h4>Algorithm</h4>
                            <p>Finds the most common facing direction and rotates all elements to face that direction. Each element has a visual indicator showing which way it "faces".</p>
                        </div>
                        <div class="detail-section">
                            <h4>Code Logic</h4>
                            <div class="code-snippet">// Quantize to 8 cardinal directions
directions = elements.map(e => 
  round(e.rotation / 45) * 45
);
mostCommon = mode(directions);
elements.forEach(e => {
  e.rotation = mostCommon;
});</div>
                        </div>
                        <div class="detail-section">
                            <h4>Design Decision</h4>
                            <p>Unified facing creates strong directional flow. When all elements point the same way, it creates dynamic movement and visual momentum in the composition.</p>
                        </div>
                    </div>
                </button>

                <button class="mode-btn" onclick="toggleModeDetails(this, 'symmetry')">
                    <div class="mode-btn-header">
                        <span class="mode-btn-title">
                            <span>🦋</span>
                            <span>Bilateral Symmetry</span>
                        </span>
                        <span class="info-icon">ⓘ</span>
                    </div>
                    <div class="mode-details">
                        <div class="detail-section">
                            <h4>Algorithm</h4>
                            <p>Mirror pairs across vertical center axis.</p>
                        </div>
                        <div class="detail-section">
                            <h4>Code Logic</h4>
                            <div class="code-snippet">offset = abs(elem[i].x - centerX);
elem[i].x = centerX - offset;
elem[i+1].x = centerX + offset;</div>
                        </div>
                    </div>
                </button>

                <button class="mode-btn" onclick="toggleModeDetails(this, 'color')">
                    <div class="mode-btn-header">
                        <span class="mode-btn-title">
                            <span>🎨</span>
                            <span>Color Harmony</span>
                        </span>
                        <span class="info-icon">ⓘ</span>
                    </div>
                    <div class="mode-details">
                        <div class="detail-section">
                            <h4>Algorithm</h4>
                            <p>Analogous or complementary color theory application.</p>
                        </div>
                        <div class="detail-section">
                            <h4>Code Logic</h4>
                            <div class="code-snippet">avgHue = mean(extractHues(colors));
hue = i % 2 === 0 ? avgHue : avgHue + 180;
color = hsl(hue, 70%, 45 + i*5);</div>
                        </div>
                    </div>
                </button>

                <button class="mode-btn" onclick="toggleModeDetails(this, 'radial')">
                    <div class="mode-btn-header">
                        <span class="mode-btn-title">
                            <span>🎯</span>
                            <span>Radial Distribution</span>
                        </span>
                        <span class="info-icon">ⓘ</span>
                    </div>
                    <div class="mode-details">
                        <div class="detail-section">
                            <h4>Algorithm</h4>
                            <p>Even distribution around circle with equal angles.</p>
                        </div>
                        <div class="detail-section">
                            <h4>Code Logic</h4>
                            <div class="code-snippet">angle = (i / count) * 2 * PI;
e.x = centerX + cos(angle) * 180;
e.y = centerY + sin(angle) * 180;</div>
                        </div>
                    </div>
                </button>
                </div>
            </div>

            <!-- CENTER: Canvas & Analysis -->
            <div class="canvas-section">
                <div class="canvas-wrapper">
                    <canvas id="canvas" width="500" height="500"></canvas>
                </div>

                <div class="quick-actions">
                    <button class="action-btn" onclick="generateNewComposition()">
                        🎲 Generate New
                    </button>
                    <button class="action-btn" onclick="resetComposition()">
                        🔄 Reset Original
                    </button>
                </div>

                <div class="order-analysis">
                    <div class="score-display">
                        <div class="overall-score" id="overallScore">0%</div>
                        <div class="score-category" id="scoreCategory">Generate to start</div>
                    </div>

                    <div class="principle-score">
                        <span class="principle-name">Hierarchy</span>
                        <div class="principle-bar">
                            <div class="principle-bar-fill" id="hierarchyBar"></div>
                        </div>
                        <span class="principle-value" id="hierarchyScore">0/10</span>
                    </div>

                    <div class="principle-score">
                        <span class="principle-name">Grouping</span>
                        <div class="principle-bar">
                            <div class="principle-bar-fill" id="groupingBar"></div>
                        </div>
                        <span class="principle-value" id="groupingScore">0/10</span>
                    </div>

                    <div class="principle-score">
                        <span class="principle-name">Structure</span>
                        <div class="principle-bar">
                            <div class="principle-bar-fill" id="structureBar"></div>
                        </div>
                        <span class="principle-value" id="structureScore">0/10</span>
                    </div>

                    <div class="principle-score">
                        <span class="principle-name">Flow</span>
                        <div class="principle-bar">
                            <div class="principle-bar-fill" id="flowBar"></div>
                        </div>
                        <span class="principle-value" id="flowScore">0/10</span>
                    </div>

                    <div class="principle-score">
                        <span class="principle-name">Spatial</span>
                        <div class="principle-bar">
                            <div class="principle-bar-fill" id="spatialBar"></div>
                        </div>
                        <span class="principle-value" id="spatialScore">0/10</span>
                    </div>

                    <div class="principle-score">
                        <span class="principle-name">Harmony</span>
                        <div class="principle-bar">
                            <div class="principle-bar-fill" id="harmonyBar"></div>
                        </div>
                        <span class="principle-value" id="harmonyScore">0/10</span>
                    </div>
                </div>
            </div>

            <!-- RIGHT PANEL: Manual Element Controls -->
            <div class="element-controls">
                <div class="panel-header">
                    <div class="panel-title">Manual Controls</div>
                    <div class="panel-description">
                        Fine-tune each element individually (16 total).
                    </div>
                </div>
                
                <div class="controls-container" id="elementControlsContainer"></div>
            </div>
        </div>

        <!-- BOTTOM: Footer -->
        <div class="footer">
            <div class="footer-content">
                <span><strong>Created by:</strong> Apratim Panwar | IISc Bangalore | <strong>Guided by:</strong> Prof. Vishal Singh</span>
            </div>
        </div>
    </div>

    <script>
        const PHI = 1.618033988749;
        const CANVAS_SIZE = 500;
        const GRID_SIZE = 8;
        const SHAPE_TYPES = ['circle', 'square', 'rectangle', 'triangle'];
        
        let canvas, ctx;
        let allElements = [];
        let originalState = [];
        let showArrows = false;
        let arrowTimer = null;

        class Element {
            constructor(type, index) {
                this.type = type;
                this.index = index;
                this.id = `${type}-${index}`;
                this.visible = false;
                this.x = CANVAS_SIZE / 2;
                this.y = CANVAS_SIZE / 2;
                this.size = 80;
                this.size2 = type === 'rectangle' ? 120 : 80;
                this.rotation = 0;
                this.color = '#1F2937';
                this.filled = true;
            }

            draw(ctx) {
                if (!this.visible) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation * Math.PI / 180);
                
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;

                switch(this.type) {
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                        this.filled ? ctx.fill() : ctx.stroke();
                        break;
                    
                    case 'square':
                        if (this.filled) {
                            ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                        } else {
                            ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
                        }
                        break;
                    
                    case 'rectangle':
                        if (this.filled) {
                            ctx.fillRect(-this.size/2, -this.size2/2, this.size, this.size2);
                        } else {
                            ctx.strokeRect(-this.size/2, -this.size2/2, this.size, this.size2);
                        }
                        break;
                    
                    case 'triangle':
                        ctx.beginPath();
                        ctx.moveTo(0, -this.size * 0.433);
                        ctx.lineTo(-this.size / 2, this.size * 0.433);
                        ctx.lineTo(this.size / 2, this.size * 0.433);
                        ctx.closePath();
                        this.filled ? ctx.fill() : ctx.stroke();
                        break;
                }
                
                // Draw face direction indicator (small arrow) - only when showArrows is true
                if (showArrows) {
                    const arrowSize = Math.min(this.size * 0.3, 15);
                    ctx.strokeStyle = this.filled ? 'rgba(255, 255, 255, 0.7)' : this.color;
                    ctx.fillStyle = this.filled ? 'rgba(255, 255, 255, 0.7)' : this.color;
                    ctx.lineWidth = 2;
                    
                    // Arrow pointing right (in local coordinates)
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(arrowSize, 0);
                    ctx.stroke();
                    
                    // Arrowhead
                    ctx.beginPath();
                    ctx.moveTo(arrowSize, 0);
                    ctx.lineTo(arrowSize - 5, -4);
                    ctx.lineTo(arrowSize - 5, 4);
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            }

            getArea() {
                switch(this.type) {
                    case 'circle': return Math.PI * (this.size / 2) ** 2;
                    case 'square': return this.size ** 2;
                    case 'rectangle': return this.size * this.size2;
                    case 'triangle': return (this.size ** 2) * Math.sqrt(3) / 4;
                    default: return 0;
                }
            }

            getVisualWeight() {
                if (!this.visible) return 0;
                
                const sizeFactor = this.getArea() / (CANVAS_SIZE * CANVAS_SIZE);
                const contrastFactor = this.filled ? 0.8 : 0.4;
                const distFromCenter = Math.sqrt((this.x - CANVAS_SIZE/2)**2 + (this.y - CANVAS_SIZE/2)**2);
                const maxDist = Math.sqrt((CANVAS_SIZE/2)**2 + (CANVAS_SIZE/2)**2);
                const positionFactor = 1 - (distFromCenter / maxDist);
                
                const rgb = this.hexToRgb(this.color);
                const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
                const saturationFactor = hsl.s / 100;
                
                return sizeFactor * 0.4 + contrastFactor * 0.3 + positionFactor * 0.2 + saturationFactor * 0.1;
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }

            rgbToHsl(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / d + 2) / 6; break;
                        case b: h = ((r - g) / d + 4) / 6; break;
                    }
                }

                return { h: h * 360, s: s * 100, l: l * 100 };
            }

            clone() {
                const cloned = new Element(this.type, this.index);
                Object.assign(cloned, JSON.parse(JSON.stringify(this)));
                return cloned;
            }
        }

        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            SHAPE_TYPES.forEach(type => {
                for (let i = 0; i < 4; i++) {
                    allElements.push(new Element(type, i + 1));
                }
            });
            
            generateNewComposition();
            buildElementControls();
        }

        function toggleModeDetails(button, mode) {
            const details = button.querySelector('.mode-details');
            const wasExpanded = details.classList.contains('expanded');
            
            document.querySelectorAll('.mode-details').forEach(d => d.classList.remove('expanded'));
            
            if (!wasExpanded) {
                details.classList.add('expanded');
            }
            
            applyOrderMode(mode);
            
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            button.classList.add('active');
        }

        function generateNewComposition() {
            const colors = ['#1F2937', '#374151', '#4B5563', '#6B7280', '#DC2626', '#EA580C', '#D97706', '#65A30D'];
            
            allElements.forEach(elem => {
                elem.visible = Math.random() > 0.4;
                if (elem.visible) {
                    elem.x = 100 + Math.random() * 300;
                    elem.y = 100 + Math.random() * 300;
                    elem.size = 40 + Math.random() * 80;
                    elem.size2 = elem.type === 'rectangle' ? elem.size * 1.5 : elem.size;
                    elem.rotation = Math.floor(Math.random() * 360);
                    elem.color = colors[Math.floor(Math.random() * colors.length)];
                    elem.filled = Math.random() > 0.2;
                }
            });
            
            saveOriginalState();
            buildElementControls();
            drawCanvas();
            analyzeOrder();
        }

        function resetComposition() {
            allElements = originalState.map(e => e.clone());
            buildElementControls();
            drawCanvas();
            analyzeOrder();
        }

        function saveOriginalState() {
            originalState = allElements.map(e => e.clone());
        }

        function toggleElement(id) {
            const elem = allElements.find(e => e.id === id);
            if (elem) {
                elem.visible = !elem.visible;
                if (elem.visible && elem.x === CANVAS_SIZE / 2 && elem.y === CANVAS_SIZE / 2) {
                    elem.x = 100 + Math.random() * 300;
                    elem.y = 100 + Math.random() * 300;
                    elem.rotation = Math.floor(Math.random() * 360);
                }
                buildElementControls();
                drawCanvas();
                analyzeOrder();
            }
        }

        function updateElementProp(id, prop, value) {
            const elem = allElements.find(e => e.id === id);
            if (elem) {
                elem[prop] = prop === 'color' ? value : parseFloat(value);
                
                // Show arrows temporarily when rotation is changed
                if (prop === 'rotation') {
                    showArrowsTemporarily();
                }
                
                drawCanvas();
                analyzeOrder();
            }
        }

        function buildElementControls() {
            const container = document.getElementById('elementControlsContainer');
            container.innerHTML = '';
            
            const icons = { circle: '⚪', square: '🟦', rectangle: '▭', triangle: '🔺' };
            
            SHAPE_TYPES.forEach(type => {
                const group = document.createElement('div');
                group.className = 'element-group';
                
                const title = document.createElement('div');
                title.className = 'element-group-title';
                title.innerHTML = `<span>${icons[type]}</span><span>${type.charAt(0).toUpperCase() + type.slice(1)}s</span>`;
                group.appendChild(title);
                
                const elements = allElements.filter(e => e.type === type);
                elements.forEach(elem => {
                    const card = document.createElement('div');
                    card.className = `element-card ${elem.visible ? 'active' : 'hidden'}`;
                    
                    card.innerHTML = `
                        <div class="element-header">
                            <span class="element-name">${type.charAt(0).toUpperCase() + type.slice(1)} ${elem.index}</span>
                            <button class="toggle-btn ${!elem.visible ? 'hidden-state' : ''}" 
                                    onclick="toggleElement('${elem.id}')">
                                ${elem.visible ? 'Hide' : 'Show'}
                            </button>
                        </div>
                        ${elem.visible ? `
                        <div class="element-controls-compact">
                            <div class="compact-control">
                                <span class="compact-label">X: ${Math.round(elem.x)}</span>
                                <input type="range" min="0" max="${CANVAS_SIZE}" value="${elem.x}" 
                                       oninput="updateElementProp('${elem.id}', 'x', this.value)">
                            </div>
                            <div class="compact-control">
                                <span class="compact-label">Y: ${Math.round(elem.y)}</span>
                                <input type="range" min="0" max="${CANVAS_SIZE}" value="${elem.y}" 
                                       oninput="updateElementProp('${elem.id}', 'y', this.value)">
                            </div>
                            <div class="compact-control size-control">
                                <span class="compact-label">Size: ${Math.round(elem.size)}</span>
                                <input type="range" min="20" max="200" value="${elem.size}" 
                                       oninput="updateElementProp('${elem.id}', 'size', this.value)">
                            </div>
                            <div class="compact-control rotation-control">
                                <span class="compact-label">Rotation: ${Math.round(elem.rotation)}°</span>
                                <input type="range" min="0" max="360" value="${elem.rotation}" 
                                       oninput="updateElementProp('${elem.id}', 'rotation', this.value)">
                            </div>
                            <div class="compact-control size-control">
                                <span class="compact-label">Color</span>
                                <input type="color" value="${elem.color}" 
                                       onchange="updateElementProp('${elem.id}', 'color', this.value)">
                            </div>
                        </div>
                        ` : ''}
                    `;
                    group.appendChild(card);
                });
                
                container.appendChild(group);
            });
        }

        function drawCanvas() {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            ctx.strokeStyle = '#F3F4F6';
            ctx.lineWidth = 1;
            for (let i = 0; i <= CANVAS_SIZE; i += GRID_SIZE * 4) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, CANVAS_SIZE);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(CANVAS_SIZE, i);
                ctx.stroke();
            }
            
            allElements.forEach(elem => elem.draw(ctx));
        }

        function getVisibleElements() {
            return allElements.filter(e => e.visible);
        }

        function showArrowsTemporarily() {
            showArrows = true;
            drawCanvas();
            
            // Clear existing timer
            if (arrowTimer) {
                clearTimeout(arrowTimer);
            }
            
            // Hide arrows after 3 seconds
            arrowTimer = setTimeout(() => {
                showArrows = false;
                drawCanvas();
            }, 3000);
        }

        function applyOrderMode(mode) {
            const visible = getVisibleElements();
            if (visible.length === 0) return;

            switch(mode) {
                case 'shape': applyShapeGrouping(visible); break;
                case 'size': applySizeUniformity(visible); break;
                case 'grid': applyStrictGrid(visible); break;
                case 'hierarchy': applyVisualWeightHierarchy(visible); break;
                case 'rhythm': applyRhythmicSpacing(visible); break;
                case 'proximity': applyProximityClustering(visible); break;
                case 'balance': applyAdvancedBalance(visible); break;
                case 'rotation': 
                    applyRotationalAlignment(visible);
                    showArrowsTemporarily();
                    break;
                case 'avgface': 
                    applyAverageFaceDirection(visible);
                    showArrowsTemporarily();
                    break;
                case 'symmetry': applyBilateralSymmetry(visible); break;
                case 'color': applyColorHarmony(visible); break;
                case 'radial': applyRadialDistribution(visible); break;
            }

            buildElementControls();
            drawCanvas();
            analyzeOrder();
        }

        function applyShapeGrouping(elements) {
            const groups = {};
            SHAPE_TYPES.forEach(type => {
                groups[type] = elements.filter(e => e.type === type);
            });

            const positions = [
                {x: 125, y: 125},
                {x: 375, y: 125},
                {x: 125, y: 375},
                {x: 375, y: 375}
            ];

            let posIndex = 0;
            SHAPE_TYPES.forEach(type => {
                if (groups[type].length > 0 && posIndex < positions.length) {
                    const basePos = positions[posIndex];
                    const radius = 40;
                    
                    groups[type].forEach((elem, i) => {
                        const angle = (i / groups[type].length) * Math.PI * 2;
                        elem.x = basePos.x + Math.cos(angle) * radius;
                        elem.y = basePos.y + Math.sin(angle) * radius;
                    });
                    posIndex++;
                }
            });
        }

        function applySizeUniformity(elements) {
            const avgSize = elements.reduce((sum, e) => sum + e.size, 0) / elements.length;
            const gridSize = Math.round(avgSize / GRID_SIZE) * GRID_SIZE;
            
            elements.forEach(elem => {
                elem.size = gridSize;
                if (elem.type === 'rectangle') {
                    elem.size2 = gridSize * 1.5;
                }
            });
        }

        function applyStrictGrid(elements) {
            elements.forEach(elem => {
                elem.x = Math.round(elem.x / GRID_SIZE) * GRID_SIZE;
                elem.y = Math.round(elem.y / GRID_SIZE) * GRID_SIZE;
                elem.size = Math.round(elem.size / GRID_SIZE) * GRID_SIZE;
                elem.rotation = Math.round(elem.rotation / 15) * 15;
                
                if (elem.type === 'rectangle') {
                    elem.size2 = Math.round(elem.size2 / GRID_SIZE) * GRID_SIZE;
                }
                
                const padding = elem.size / 2 + GRID_SIZE;
                elem.x = Math.max(padding, Math.min(CANVAS_SIZE - padding, elem.x));
                elem.y = Math.max(padding, Math.min(CANVAS_SIZE - padding, elem.y));
            });
        }

        function applyVisualWeightHierarchy(elements) {
            const sorted = [...elements].sort((a, b) => b.getVisualWeight() - a.getVisualWeight());
            
            sorted.forEach((elem, i) => {
                elem.size = 120 / Math.pow(PHI, i * 0.6);
                if (elem.type === 'rectangle') {
                    elem.size2 = elem.size * PHI;
                }
            });

            if (sorted.length > 0) {
                sorted[0].x = CANVAS_SIZE / 2;
                sorted[0].y = CANVAS_SIZE / 2;
            }

            for (let i = 1; i < sorted.length; i++) {
                const angle = (i / (sorted.length - 1)) * Math.PI * 2;
                const radius = 160;
                sorted[i].x = CANVAS_SIZE / 2 + Math.cos(angle) * radius;
                sorted[i].y = CANVAS_SIZE / 2 + Math.sin(angle) * radius;
            }
        }

        function applyRhythmicSpacing(elements) {
            const sorted = [...elements].sort((a, b) => a.x - b.x);
            const spacing = CANVAS_SIZE / (sorted.length + 1);
            
            sorted.forEach((elem, i) => {
                elem.x = spacing * (i + 1);
                elem.y = CANVAS_SIZE / 2;
                elem.size = i % 2 === 0 ? 70 : 50;
                elem.rotation = 0;
                
                if (elem.type === 'rectangle') {
                    elem.size2 = elem.size * 1.5;
                }
            });
        }

        function applyProximityClustering(elements) {
            for (let pass = 0; pass < 10; pass++) {
                elements.forEach(elem => {
                    let nearestDist = Infinity;
                    let nearest = null;
                    
                    elements.forEach(other => {
                        if (elem !== other) {
                            const dist = Math.sqrt((elem.x - other.x)**2 + (elem.y - other.y)**2);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearest = other;
                            }
                        }
                    });
                    
                    if (nearest) {
                        const minDist = (elem.size + nearest.size) / 2 + 10;
                        if (nearestDist > minDist) {
                            elem.x += (nearest.x - elem.x) * 0.3;
                            elem.y += (nearest.y - elem.y) * 0.3;
                        }
                    }
                });
            }
        }

        function applyAdvancedBalance(elements) {
            let weightedX = 0, weightedY = 0, totalWeight = 0;
            
            elements.forEach(e => {
                const rgb = e.hexToRgb(e.color);
                const L = Math.pow(0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b, 1/2.2) / 255;
                const weight = e.getArea() * L;
                
                weightedX += e.x * weight;
                weightedY += e.y * weight;
                totalWeight += weight;
            });

            if (totalWeight > 0) {
                const centerX = weightedX / totalWeight;
                const centerY = weightedY / totalWeight;
                const offsetX = (CANVAS_SIZE / 2) - centerX;
                const offsetY = (CANVAS_SIZE / 2) - centerY;

                elements.forEach(elem => {
                    elem.x += offsetX;
                    elem.y += offsetY;

                    const padding = elem.size / 2 + 20;
                    elem.x = Math.max(padding, Math.min(CANVAS_SIZE - padding, elem.x));
                    elem.y = Math.max(padding, Math.min(CANVAS_SIZE - padding, elem.y));
                });
            }
        }

        function applyRotationalAlignment(elements) {
            const sinSum = elements.reduce((sum, e) => sum + Math.sin(e.rotation * Math.PI / 180), 0);
            const cosSum = elements.reduce((sum, e) => sum + Math.cos(e.rotation * Math.PI / 180), 0);
            const avgRotation = Math.atan2(sinSum, cosSum) * 180 / Math.PI;
            
            elements.forEach(elem => {
                elem.rotation = avgRotation;
            });
        }

        function applyAverageFaceDirection(elements) {
            // Quantize rotations to 8 cardinal directions (0, 45, 90, 135, 180, 225, 270, 315)
            const cardinalDirections = elements.map(e => {
                return Math.round(e.rotation / 45) * 45;
            });
            
            // Find the most common direction (mode)
            const directionCounts = {};
            cardinalDirections.forEach(dir => {
                const normalized = ((dir % 360) + 360) % 360; // Normalize to 0-360
                directionCounts[normalized] = (directionCounts[normalized] || 0) + 1;
            });
            
            // Get the most frequent direction
            let mostCommonDirection = 0;
            let maxCount = 0;
            for (const [dir, count] of Object.entries(directionCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    mostCommonDirection = parseInt(dir);
                }
            }
            
            // Align all elements to the most common direction
            elements.forEach(elem => {
                elem.rotation = mostCommonDirection;
            });
        }

        function applyBilateralSymmetry(elements) {
            const centerX = CANVAS_SIZE / 2;
            const sorted = [...elements].sort((a, b) => Math.abs(a.x - centerX) - Math.abs(b.x - centerX));

            for (let i = 0; i < sorted.length; i += 2) {
                const elem1 = sorted[i];
                const offsetX = Math.abs(elem1.x - centerX);
                
                elem1.x = centerX - offsetX;
                elem1.rotation = -elem1.rotation;
                
                if (i + 1 < sorted.length) {
                    const elem2 = sorted[i + 1];
                    elem2.x = centerX + offsetX;
                    elem2.y = elem1.y;
                    elem2.size = elem1.size;
                    elem2.size2 = elem1.size2;
                    elem2.rotation = elem1.rotation;
                }
            }
        }

        function applyColorHarmony(elements) {
            const avgHue = elements.reduce((sum, e) => {
                const rgb = e.hexToRgb(e.color);
                const hsl = e.rgbToHsl(rgb.r, rgb.g, rgb.b);
                return sum + hsl.h;
            }, 0) / elements.length;
            
            elements.forEach((elem, i) => {
                let hue;
                if (elements.length <= 4) {
                    hue = i % 2 === 0 ? avgHue : (avgHue + 180) % 360;
                } else {
                    hue = avgHue + (i - elements.length / 2) * (60 / elements.length);
                }
                
                const lightness = 45 + (i * 5);
                elem.color = `hsl(${hue % 360}, 70%, ${lightness}%)`;
                elem.filled = true;
            });
        }

        function applyRadialDistribution(elements) {
            const centerX = CANVAS_SIZE / 2;
            const centerY = CANVAS_SIZE / 2;
            const radius = 150;
            
            elements.forEach((elem, i) => {
                const angle = (i / elements.length) * Math.PI * 2;
                elem.x = centerX + Math.cos(angle) * radius;
                elem.y = centerY + Math.sin(angle) * radius;
                elem.rotation = angle * 180 / Math.PI + 90;
            });
        }

        function analyzeOrder() {
            const visible = getVisibleElements();
            if (visible.length === 0) {
                updateScoreDisplay(0, 0, 0, 0, 0, 0, 0);
                return;
            }

            const hierarchyScore = analyzeHierarchy(visible);
            const groupingScore = analyzeGrouping(visible);
            const structureScore = analyzeStructure(visible);
            const flowScore = analyzeFlow(visible);
            const spatialScore = analyzeSpatial(visible);
            const harmonyScore = analyzeHarmony(visible);

            const overallScore = (
                hierarchyScore * 0.20 +
                groupingScore * 0.18 +
                structureScore * 0.16 +
                flowScore * 0.15 +
                spatialScore * 0.12 +
                harmonyScore * 0.19
            ) * 10;

            updateScoreDisplay(overallScore, hierarchyScore, groupingScore, structureScore, flowScore, spatialScore, harmonyScore);
        }

        function analyzeHierarchy(elements) {
            const weights = elements.map(e => e.getVisualWeight());
            if (weights.length < 2) return 5.0;

            const uniqueWeights = new Set(weights.map(w => Math.round(w * 10) / 10)).size;
            const range = Math.max(...weights) - Math.min(...weights);
            const avgWeight = weights.reduce((a, b) => a + b) / weights.length;
            const variance = weights.reduce((sum, w) => sum + (w - avgWeight)**2, 0) / weights.length;

            return Math.min(10, uniqueWeights * 2 + range * 5 + Math.sqrt(variance) * 3);
        }

        function analyzeGrouping(elements) {
            if (elements.length < 2) return 10.0;
            
            const distances = [];
            for (let i = 0; i < elements.length; i++) {
                for (let j = i + 1; j < elements.length; j++) {
                    const dist = Math.sqrt((elements[i].x - elements[j].x)**2 + (elements[i].y - elements[j].y)**2);
                    distances.push(dist);
                }
            }

            const avgDist = distances.reduce((a, b) => a + b) / distances.length;
            const stdDev = Math.sqrt(distances.reduce((sum, d) => sum + (d - avgDist)**2, 0) / distances.length);

            return Math.min(10, (stdDev / avgDist) * 15);
        }

        function analyzeStructure(elements) {
            const xPositions = elements.map(e => e.x);
            const yPositions = elements.map(e => e.y);
            
            const xGridScore = xPositions.filter(x => Math.abs(x % GRID_SIZE) < 2).length / xPositions.length;
            const yGridScore = yPositions.filter(y => Math.abs(y % GRID_SIZE) < 2).length / yPositions.length;
            
            const sizes = elements.map(e => e.size);
            const avgSize = sizes.reduce((a, b) => a + b) / sizes.length;
            const sizeVariance = sizes.reduce((sum, s) => sum + (s - avgSize)**2, 0) / sizes.length;
            const sizeConsistency = 1 - Math.min(1, Math.sqrt(sizeVariance) / avgSize);
            
            const rotations = elements.map(e => e.rotation);
            const rotationAlignment = rotations.filter(r => r % 15 < 2).length / rotations.length;

            return ((xGridScore + yGridScore) * 4 + sizeConsistency * 4 + rotationAlignment * 2) / 1.5;
        }

        function analyzeFlow(elements) {
            if (elements.length < 2) return 10.0;

            const sorted = [...elements].sort((a, b) => b.getVisualWeight() - a.getVisualWeight());
            
            let score = 0;
            for (let i = 0; i < sorted.length - 1; i++) {
                const xDiff = sorted[i + 1].x - sorted[i].x;
                const yDiff = sorted[i + 1].y - sorted[i].y;
                
                if (xDiff >= 0 && yDiff >= 0) score += 1;
                else if (Math.abs(yDiff) < Math.abs(xDiff) && xDiff > 0) score += 0.7;
                else if (Math.abs(xDiff) < Math.abs(yDiff) && yDiff > 0) score += 0.6;
                else score += 0.3;
            }
            
            return (score / (sorted.length - 1)) * 10;
        }

        function analyzeSpatial(elements) {
            const totalArea = CANVAS_SIZE * CANVAS_SIZE;
            const occupiedArea = elements.reduce((sum, e) => sum + e.getArea(), 0);
            const whiteSpaceRatio = (totalArea - occupiedArea) / totalArea;
            
            const whiteSpaceScore = 10 - Math.abs(whiteSpaceRatio - 0.4) * 15;
            
            let weightedX = 0, weightedY = 0, totalWeight = 0;
            elements.forEach(e => {
                const rgb = e.hexToRgb(e.color);
                const L = Math.pow(0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b, 1/2.2) / 255;
                const weight = e.getArea() * L;
                weightedX += e.x * weight;
                weightedY += e.y * weight;
                totalWeight += weight;
            });
            
            const centerX = totalWeight > 0 ? weightedX / totalWeight : CANVAS_SIZE / 2;
            const centerY = totalWeight > 0 ? weightedY / totalWeight : CANVAS_SIZE / 2;
            
            const deviation = Math.sqrt((centerX - CANVAS_SIZE/2)**2 + (centerY - CANVAS_SIZE/2)**2);
            const balanceScore = 10 - (deviation / (CANVAS_SIZE/2)) * 5;
            
            return (Math.max(0, whiteSpaceScore) + Math.max(0, balanceScore)) / 2;
        }

        function analyzeHarmony(elements) {
            const sizes = elements.map(e => e.size);
            const avgSize = sizes.reduce((a, b) => a + b, 0) / sizes.length;
            const sizeVariance = sizes.reduce((sum, s) => sum + (s - avgSize)**2, 0) / sizes.length;
            const sizeDiversity = Math.sqrt(sizeVariance) / avgSize;
            
            const rotations = elements.map(e => e.rotation);
            const avgRotation = rotations.reduce((a, b) => a + b) / rotations.length;
            const rotationVariance = rotations.reduce((sum, r) => sum + (r - avgRotation)**2, 0) / rotations.length;
            const rotationConsistency = 1 - Math.min(1, Math.sqrt(rotationVariance) / 180);
            
            const filledCount = elements.filter(e => e.filled).length;
            const filledRatio = filledCount / elements.length;
            const filledConsistency = Math.min(filledRatio, 1 - filledRatio) * 2;

            const sizeScore = Math.max(0, 10 - Math.abs(sizeDiversity - 0.3) * 20);
            const rotationScore = rotationConsistency * 10;
            const filledScore = filledConsistency * 10;

            return (sizeScore * 0.5 + rotationScore * 0.3 + filledScore * 0.2);
        }

        function updateScoreDisplay(overall, hierarchy, grouping, structure, flow, spatial, harmony) {
            document.getElementById('overallScore').textContent = Math.round(overall) + '%';
            
            let category;
            if (overall >= 90) category = '🏆 Excellent Order';
            else if (overall >= 80) category = '⭐ Very Good Order';
            else if (overall >= 70) category = '✓ Good Order';
            else if (overall >= 60) category = '~ Fair Order';
            else category = '✗ Needs Improvement';
            document.getElementById('scoreCategory').textContent = category;
            
            updatePrincipleScore('hierarchy', hierarchy);
            updatePrincipleScore('grouping', grouping);
            updatePrincipleScore('structure', structure);
            updatePrincipleScore('flow', flow);
            updatePrincipleScore('spatial', spatial);
            updatePrincipleScore('harmony', harmony);
        }

        function updatePrincipleScore(principle, score) {
            const scoreElem = document.getElementById(principle + 'Score');
            const barElem = document.getElementById(principle + 'Bar');
            
            scoreElem.textContent = score.toFixed(1) + '/10';
            barElem.style.width = (score * 10) + '%';
            
            if (score >= 8) barElem.style.background = '#10B981';
            else if (score >= 6) barElem.style.background = '#F59E0B';
            else barElem.style.background = '#EF4444';
        }

        window.onload = init;
    </script>
</body>
</html>
